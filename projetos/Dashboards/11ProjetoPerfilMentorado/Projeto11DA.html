<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Gabriel Ferreira">
<meta name="dcterms.date" content="2024-06-02">

<title>Projeto: Dashboard de Análise de Perfil de Mentorado e Potencial de Carreira</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Projeto11DA_files/libs/clipboard/clipboard.min.js"></script>
<script src="Projeto11DA_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Projeto11DA_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Projeto11DA_files/libs/quarto-html/popper.min.js"></script>
<script src="Projeto11DA_files/libs/quarto-html/tippy.umd.min.js"></script>
<link href="Projeto11DA_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Projeto11DA_files/libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Projeto11DA_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Projeto11DA_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Projeto11DA_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-full">

<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Projeto: Dashboard de Análise de Perfil de Mentorado e Potencial de Carreira</h1>
</div>



<div class="quarto-title-meta column-page">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Gabriel Ferreira </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">June 2, 2024</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introdução" class="level1">
<h1>Introdução</h1>
<p>Este projeto apresenta um Dashboard analítico desenvolvido para traçar o perfil de indivíduos interessados em mentoria e desenvolvimento de carreira. O principal objetivo é fornecer uma visão detalhada sobre as características demográficas, formação acadêmica, experiência profissional, nível de conhecimento em diversas ferramentas e tecnologias, e aspirações de carreira dos mentorados. O painel visou capacitar a empresa que trabalha com programas de mentoria a compreender melhor seu público-alvo, personalizar as ofertas de capacitação, otimizar a alocação de recursos e identificar talentos com alto potencial para desenvolvimento e migração de área.</p>
<section id="estrutura-do-projeto" class="level2">
<h2 data-anchor-id="estrutura-do-projeto">Estrutura do Projeto</h2>
<p>O dashboard é organizado para oferecer uma análise multidimensional do perfil dos indivíduos:</p>
<ul>
<li><strong>Visão Geral do Perfil</strong>: Total de pessoas analisadas, distribuição por gênero e taxa de conversão.</li>
<li><strong>Dados Demográficos</strong>: Faixa etária, estado civil, origem do lead e distribuição geográfica por estado.</li>
<li><strong>Perfil Profissional e Acadêmico</strong>: Média salarial, formação, interesse em migrar para outras áreas e tempo disponível para estudo.</li>
<li><strong>Nível de Conhecimento em Ferramentas</strong>: Avaliação detalhada do conhecimento em SQL, Gestão de Projetos, Power BI, Dados e Excel, além do contato com metodologias ágeis (Kanban/Scrum).</li>
</ul>
</section>
<section id="tecnologias-utilizadas" class="level2">
<h2 data-anchor-id="tecnologias-utilizadas">Tecnologias Utilizadas</h2>
<p>Para a construção deste dashboard analítico, as ferramentas empregadas foram:</p>
<ul>
<li><strong>Power BI Desktop</strong>: Para conectar as quatro bases de dados em Excel, realizar a modelagem e transformação necessárias, desenvolver as medidas DAX para cálculos complexos e construir os visuais interativos que compõem o dashboard.</li>
<li><strong>Figma</strong>: A prototipação e o design do dashboard foram feitos com o Figma, garantindo uma experiência de usuário intuitiva e visualmente atraente.</li>
</ul>
</section>
<section id="processo-de-etl-extração-transformação-e-carregamento" class="level2">
<h2 data-anchor-id="processo-de-etl-extração-transformação-e-carregamento">Processo de ETL (Extração, Transformação e Carregamento)</h2>
<p>O processo de ETL para o Dashboard de Análise de Perfil de Mentorado foi estruturado para integrar informações de diversas fontes, garantindo uma visão completa e precisa:</p>
<ol type="1">
<li><strong>Extração</strong>: Os dados brutos foram extraídos de quatro bases de dados distintas, todas em formato Excel. Cada base possivelmente continha informações específicas sobre um aspecto do perfil do mentorado.</li>
<li><strong>Transformação</strong>: No Power Query, parte integrante do Power BI, foram realizadas diversas operações de limpeza e enriquecimento. Isso incluiu:
<ul>
<li>Tratamento de dados, como padronização de campos e correção de valores.</li>
<li>Criação de novas colunas e métricas calculadas essenciais para as análises, utilizando a linguagem M.</li>
<li>A modelagem de dados foi crucial. Relacionamentos foram estabelecidos entre as quatro bases de dados, garantindo que todas as informações pudessem ser corretamente agregadas e filtradas para análises multidimensionais do perfil.</li>
</ul></li>
<li><strong>Carregamento</strong>: Após as etapas de extração e transformação, os dados foram carregados no modelo de dados do Power BI, estando prontos para alimentar todos os gráficos e tabelas do dashboard, permitindo a exploração interativa dos perfis analisados.</li>
</ol>
</section>
</section>
<section id="dashboard" class="level1">
<h1>Dashboard</h1>
<p>Com uma organização que facilita a compreensão das diversas características dos indivíduos. A interface combina cartões de KPI para os totais gerais, gráficos de barras e rosca para distribuições percentuais (gênero, faixa etária, estado civil), gráficos de barras horizontais para rankings (origem do lead, estados) e visuais de barras para níveis de conhecimento e tempo de estudo. A interatividade é um recurso central, permitindo a filtragem por diferentes dimensões e facilitando a identificação de segmentos específicos de mentorados.</p>
<div style="text-align:center;">
<p><img src="imagem1.png" alt=""></p>
</div>
<section id="insights" class="level2">
<h2 data-anchor-id="insights">Insights</h2>
<p>A análise dos dados apresentados no dashboard revelou insights valiosos sobre o perfil dos mentorados:</p>
<ul>
<li><strong>Público Principal e Taxa de Conversão</strong>:
<ul>
<li>O painel indica um Total de Compradores de 660 indivíduos.</li>
<li>A Taxa de Conversão geral é de 67%, com 71,06% de Compradores Homens e 28,94% de Compradoras Mulheres.</li>
<li>Curiosamente, 23,18% dos Compradores possuem filhos, oferecendo um detalhe sobre o perfil familiar.</li>
</ul></li>
</ul>
<div style="text-align:center;">
<p><img src="imagem2.png" alt=""></p>
</div>
<ul>
<li><strong>Distribuição Demográfica</strong>:
<ul>
<li>Entre os indivíduos analisados, a maioria tem entre 25 e 35 anos (394), seguido por 18 a 25 anos (163) e 35 a 45 anos (90). Isso aponta para um público predominantemente jovem a meia-idade.
<div style="text-align:center;">
<img src="imagem3.png" alt="">
</div></li>
<li>A distribuição por Estado Civil mostra que a maior parte é Solteira (436), seguida por Casado(a) (207).
<div style="text-align:center;">
<img src="imagem5.png" alt="">
</div></li>
<li>Em termos de Origem do Lead, o Instagram (590) é a principal fonte, destacando a relevância dessa plataforma para o engajamento desse público.
<div style="text-align:center;">
<img src="imagem6.png" alt="">
</div></li>
<li>A distribuição geográfica dos leads é concentrada em SP (171), RS (82) e RJ (73), indicando os principais mercados de interesse.
<div style="text-align:center;">
<img src="imagem4.png" alt="">
</div></li>
</ul></li>
<li><strong>Perfil Profissional e Aspirações</strong>:
<ul>
<li>A Média Salarial dos participantes é de R$ 3.778 fornecendo um panorama financeiro.
<div style="text-align:center;">
<img src="imagem7.png" alt="">
</div></li>
<li>Um percentual significativo de 87,88% dos indivíduos tem interesse em Migrar para uma Nova Área, sublinhando a busca por desenvolvimento e novas oportunidades de carreira.
<div style="text-align:center;">
<img src="imagem8.png" alt="">
</div></li>
<li>Em relação ao Tempo Disponível para Estudo, a maior parte dedica 2 a 4 horas (270 pessoas), seguido por 1 a 2 horas (236 pessoas), o que é importante para o planejamento de programas de estudo.
<div style="text-align:center;">
<img src="imagem9.png" alt="">
</div></li>
</ul></li>
<li><strong>Nível de Conhecimento e Formação</strong>:
<ul>
<li>A análise de conhecimento em Excel (66,21%) é a mais alta, seguida por Conhecimento em Dados (44,85%) e Power BI (22,58%). O conhecimento em SQL (14,55%) e Gestão de Projetos (18,33%) são menores, indicando lacunas potenciais.
<div style="text-align:center;">
<img src="imagem10.png" alt="">
</div></li>
<li>Em termos de Formação, a maioria possui Ensino Superior Completo (302), seguido por Ensino Superior Incompleto (161) e Ensino Médio Completo (147).
<div style="text-align:center;">
<img src="imagem11.png" alt="">
</div></li>
<li>No detalhe de Conhecimento em Power BI, Excel e SQL, a categoria “Básico” é a mais comum, e um percentual considerável “Nunca teve contato”, especialmente em SQL e Power BI. Isso ressalta a necessidade de programas de formação fundamental nessas áreas.</li>
<li>Aprofundando em Conhecimento em Power BI (DAX, M), 346 pessoas têm nível básico. Em Nível em Excel, 346 estão no básico. Em Nível de SQL, 243 estão no básico. Isso reforça a demanda por capacitação introdutória.</li>
<li>Quanto ao contato com Kanban/Scrum, a maioria “Não teve contato” (378) ou “Tem dificuldade” (180), indicando uma oportunidade para treinamento em metodologias ágeis.
<div style="text-align:center;">
<p><img src="imagem12.png" alt=""></p>
</div></li>
</ul></li>
</ul>
</section>
<section id="considerações" class="level2">
<h2 data-anchor-id="considerações">Considerações</h2>
<p>O dashboard oferece uma base sólida para aprimorar programas de capacitação e estratégias de recrutamento. A partir dos insights obtidos, algumas considerações importantes surgem:</p>
<ul>
<li><strong>Desenvolvimento de Habilidades</strong>: Há uma clara demanda por conhecimento em <strong>Dados</strong> e <strong>Excel</strong>, e uma oportunidade para programas de base em <strong>Power BI</strong> e <strong>SQL</strong>, visto que muitos estão em nível básico ou nunca tiveram contato.</li>
<li><strong>Atração e Engajamento</strong>: O Instagram é um canal eficaz para atrair leads. Compreender o perfil do público (jovens adultos, solteiros) e suas aspirações (migrar de área, buscar desenvolvimento) pode otimizar as campanhas de engajamento.</li>
<li><strong>Adaptação de Programas de Estudo</strong>: A maioria dos mentorados dispõe de 2 a 4 horas para estudo, o que deve ser considerado ao estruturar a carga horária e o formato dos cursos.</li>
<li><strong>Treinamento em Metodologias Ágeis</strong>: A alta proporção de pessoas sem contato ou com dificuldade em Kanban/Scrum sugere uma grande demanda latente por essa habilidade, essencial no mercado de trabalho atual.</li>
<li><strong>Segmentação por Região</strong>: A concentração de leads em estados como SP, RS e RJ pode guiar a alocação de recursos e a realização de eventos presenciais ou focados regionalmente.</li>
</ul>
</section>
<section id="conclusão" class="level2">
<h2 data-anchor-id="conclusão">Conclusão</h2>
<p>O Dashboard foi uma ferramenta analítica estratégica que transformou dados brutos em inteligência que geraram impacto para a empresa. Sua principal contribuição residiu na capacidade de:</p>
<ul>
<li>Fornecer um panorama detalhado das características demográficas, acadêmicas e profissionais dos mentorados.</li>
<li>Identificar lacunas de conhecimento e áreas de alta demanda por desenvolvimento de habilidades.</li>
<li>Permitir a personalização de ofertas de capacitação e a otimização de estratégias de engajamento.</li>
</ul>
<p>Esse projeto teve como resultado: - Otimização de Custos de Marketing em 30%: Contribuição direta para a redução de 30% nos custos de marketing dos clientes, através do desenvolvimento de dashboards que permitiram a análise de performance de campanhas e a otimização da alocação de investimentos. Este resultado foi alcançado após propor uma nova estratégia de segmentação de público, baseada em insights extraídos da análise de dados, para direcionar os funis de venda de forma mais eficaz.</p>
</section>
<section id="link-para-o-dashboard" class="level2">
<h2 data-anchor-id="link-para-o-dashboard">Link para o Dashboard:</h2>
<p><a href="https://app.powerbi.com/groups/me/reports/33d5b95e-9fb9-47d2-8af1-a0eeaa0ded0d/ReportSection259bd8bfc3ddcb04fdf2?experience=power-bi" target="_blank" rel="noopener noreferrer"> Clique aqui para acessar o relatório no Power BI </a></p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>