<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.31">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Gabriel Ferreira">
<meta name="dcterms.date" content="2022-07-10">

<title>Projeto: Dashboard Tech Trends - Análise de Marketing Digital</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Projeto4DA_files/libs/clipboard/clipboard.min.js"></script>
<script src="Projeto4DA_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="Projeto4DA_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="Projeto4DA_files/libs/quarto-html/popper.min.js"></script>
<script src="Projeto4DA_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Projeto4DA_files/libs/quarto-html/anchor.min.js"></script>
<link href="Projeto4DA_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Projeto4DA_files/libs/quarto-html/quarto-syntax-highlighting-e1a5c8363afafaef2c763b6775fbf3ca.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Projeto4DA_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Projeto4DA_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Projeto4DA_files/libs/bootstrap/bootstrap-bb462d781dde1847d9e3ccf7736099dd.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">


</head>

<body class="quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-full">

<main class="content column-page" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Projeto: Dashboard Tech Trends - Análise de Marketing Digital</h1>
</div>



<div class="quarto-title-meta column-page">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Gabriel Ferreira </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 10, 2022</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<section id="introdução" class="level1">
<h1>Introdução</h1>
<p>Este projeto apresenta um Dashboard de Marketing Analytics, construído para fornecer uma visão abrangente do desempenho das campanhas digitais e do comportamento do usuário. O objetivo principal é capacitar as equipes de marketing a monitorar métricas chave como transações, receita, taxas de conversão e rejeição, e tempo médio na página, permitindo uma análise aprofundada por canal e campanha. O painel visa otimizar a alocação de recursos, identificar canais de maior performance e refinar estratégias para maximizar o retorno sobre o investimento em marketing digital.</p>
<section id="estrutura-do-projeto" class="level2">
<h2 class="anchored" data-anchor-id="estrutura-do-projeto">Estrutura do Projeto</h2>
<p>Os principais requisitos e indicadores desenvolvidos para esta análise foram:</p>
<ul>
<li><strong>Visão Geral de Performance</strong>: Exibição dos totais de Transações, Receita, Taxa de Conversão Geral, Taxa de Rejeição Geral e Tempo Médio na Página.</li>
<li><strong>Tendência Diária da Taxa de Conversão</strong>: Gráfico de linha para visualizar a variação da taxa de conversão ao longo dos dias, identificando picos e vales.</li>
<li><strong>Performance por Canal de Tráfego</strong>: Análise da Taxa de Rejeição por Meio (CPC, Referral, Organic Search, Social, Direct, Paid Search) para avaliar a qualidade do tráfego.</li>
<li><strong>Distribuição de Tráfego por Origem</strong>: Quantificação do tráfego proveniente de diferentes plataformas e fontes (Google, Facebook, Twitter, Direct, Bing).</li>
<li><strong>Análise de Desempenho de Campanhas</strong>: Tabela detalhada apresentando Taxa Média de Conversão, Taxa de Rejeição e Média de Páginas Visualizadas por Campanha e Meio, permitindo uma avaliação granular da efetividade.</li>
</ul>
</section>
<section id="tecnologias-utilizadas" class="level2">
<h2 class="anchored" data-anchor-id="tecnologias-utilizadas">Tecnologias Utilizadas</h2>
<p>Para a construção deste dashboard analítico, as ferramentas empregadas foram:</p>
<ul>
<li><strong>Power BI Desktop</strong>: Para conectar as fontes de dados, realizar a modelagem e transformação necessárias, e desenvolver os visuais interativos que compõem o dashboard.</li>
<li><strong>Figma</strong>: A prototipação e o design do dashboard foram feitos com o Figma, garantindo uma experiência de usuário intuitiva e visualmente atraente.</li>
</ul>
</section>
<section id="processo-de-etl-extração-transformação-e-carregamento" class="level2">
<h2 class="anchored" data-anchor-id="processo-de-etl-extração-transformação-e-carregamento">Processo de ETL (Extração, Transformação e Carregamento)</h2>
<p>O processo de ETL para o Dashboard Tech Trends foi:</p>
<ol type="1">
<li><strong>Extração</strong>: Os dados foram extraídos de uma base de dados que contém informações de marketing digital, provavelmente de plataformas de análise de tráfego web. Os dados foram fornecidos em um arquivo <code>.csv</code>, contendo métricas de desempenho por dia, canal, campanha e origem.</li>
<li><strong>Transformação</strong>: No Power Query, parte integrante do Power BI, diversas operações de limpeza e enriquecimento foram realizadas. Isso incluiu:
<ul>
<li>Tratamento de valores ausentes ou inconsistentes.</li>
<li>Padronização de nomes de canais e campanhas.</li>
</ul></li>
<li><strong>Carregamento</strong>: Após as etapas de extração e transformação, os dados foram carregados no modelo de dados do Power BI, estando prontos para alimentar todos os gráficos e tabelas do dashboard, permitindo a exploração interativa.</li>
</ol>
</section>
</section>
<section id="dashboard" class="level1">
<h1>Dashboard</h1>
<p>O dashboard apresenta um design limpo e funcional, com indicadores chave em destaque para uma compreensão imediata da performance geral. Os visuais são organizados de forma lógica, incluindo gráficos de linha para tendências, gráficos de barras para comparações entre canais e origens, e tabelas detalhadas para a performance de campanhas. A interatividade é um ponto forte, permitindo que os usuários explorem os dados a fundo, filtrando por diferentes dimensões e obtendo insights específicos para suas necessidades de marketing.</p>
<div style="text-align:center;">
<p><img src="imagem1.png" alt=""></p>
</div>
<section id="insights" class="level2">
<h2 class="anchored" data-anchor-id="insights">Insights</h2>
<p>A análise dos dados apresentados no dashboard revelou insights valiosos sobre a performance das estratégias de marketing digital:</p>
<ul>
<li><strong>Visão Geral da Performance de Marketing</strong>:
<ul>
<li>O dashboard destaca indicadores essenciais: <strong>7,5 mil transações</strong>, gerando <strong>$1,7 milhão em receita</strong>.</li>
<li>A <strong>taxa de conversão geral é de 10,0%</strong>, enquanto a <strong>taxa de rejeição é de 49,5%</strong>.</li>
<li>Um ponto que chama a atenção é o <strong>tempo médio na página de 2 horas e 36 minutos</strong>. Embora seja um indicador de engajamento, um tempo tão elevado pode sugerir um conteúdo muito denso ou a necessidade de otimizar a jornada do usuário para conversão mais rápida, dependendo do tipo de negócio.</li>
</ul></li>
</ul>
<div style="text-align:center;">
<p><img src="imagem2.png" alt=""></p>
</div>
<ul>
<li><strong>Tendência da Taxa de Conversão por Dia</strong>:
<ul>
<li>O gráfico de linha “Taxa de Conversão por Dia” mostra a flutuação diária da taxa de conversão. Com rótulos de data explícitos, a visualização permite identificar os dias de maior e menor performance, auxiliando no planejamento de ações em dias específicos.</li>
</ul></li>
</ul>
<div style="text-align:center;">
<p><img src="imagem3.png" alt=""></p>
</div>
<ul>
<li><strong>Taxa de Rejeição por Meio de Tráfego</strong>:
<ul>
<li>A <strong>Taxa de Rejeição por Meio</strong> é um indicador crítico da qualidade do tráfego. O “Direct” (Mensagem Direta) apresenta a menor taxa de rejeição, com <strong>46,4%</strong>, indicando que este canal atrai visitantes mais qualificados.</li>
<li>Em contrapartida, o canal “CPC” (Custo por Clique) tem a maior taxa de rejeição, atingindo <strong>52,1%</strong>. Isso sugere que, embora possa gerar tráfego, parte desse tráfego pode não ser tão relevante ou engajada.</li>
</ul></li>
</ul>
<div style="text-align:center;">
<p><img src="imagem4.png" alt=""></p>
</div>
<ul>
<li><strong>Distribuição de Tráfego por Origem</strong>:
<ul>
<li>As principais origens de tráfego são Google Search (4,9 mil)** e Direct (3,3 mil).</li>
<li>O Facebook (2,5 mil) também contribui significativamente, enquanto o tráfego “Bing” (0,8 mil) e “Twitter” (0,8 mil) são menores. Este insight é fundamental para entender de onde vêm os usuários e para otimizar o investimento em diferentes plataformas.</li>
</ul></li>
</ul>
<div style="text-align:center;">
<p><img src="imagem5.png" alt=""></p>
</div>
<ul>
<li><strong>Desempenho Detalhado de Campanhas</strong>:
<ul>
<li>A tabela “Média de Taxa de Conversão, Taxa de Rejeição, Média de Páginas Visualizadas” por Campanha e Meio oferece insights valiosos:
<ul>
<li>A campanha “Summer Sale” via tráfego “Direct” apresenta a mais baixa Taxa de Rejeição (39%) e uma média de páginas visualizadas de 4,22.</li>
<li>A campanha “New Year Deal” via “Direct” se destaca pela segunda menor Taxa de Rejeição (39,3%), o que, combinado com uma média de páginas visualizadas de 4,51 , indica um tráfego de altíssima qualidade e engajamento.</li>
<li>As campanhas (Summer Sale) via CPC e Black Friday via Social também mostram fortes resultados em conversão e páginas visualizadas, sugerindo que o canal CPC, apesar da alta taxa de rejeição geral, pode ser muito eficaz quando direcionado a campanhas específicas.</li>
<li>A campanha “Black Friday” via “Direct” possui a maior taxa de rejeição entre as listadas (56,5%), mas ainda assim é um resultado considerável.</li>
</ul></li>
</ul></li>
</ul>
<div style="text-align:center;">
<p><img src="imagem6.png" alt=""></p>
</div>
</section>
<section id="considerações" class="level2">
<h2 class="anchored" data-anchor-id="considerações">Considerações</h2>
<p>O dashboard oferece insights acionáveis para otimizar as estratégias de marketing digital. A partir dos dados apresentados, algumas considerações importantes surgem:</p>
<ul>
<li><strong>Otimização de Canais de Tráfego</strong>: A empresa deve investigar a causa da alta taxa de rejeição do canal CPC. Se a taxa for muito alta para o CPC geral, pode ser necessário ajustar a segmentação de público-alvo ou a relevância dos anúncios para atrair usuários mais engajados. Em contraste, o “Direct” deve ser priorizado, dada sua menor taxa de rejeição, indicando maior qualidade do tráfego.</li>
<li><strong>Capitalização de Campanhas de Sucesso</strong>: As campanhas de “Summer Sale” (tanto Direct quanto CPC) são exemplos de sucesso. É crucial analisar os fatores que as tornaram tão eficazes (oferta, criativos, segmentação) e replicar esses aprendizados em futuras campanhas.</li>
<li><strong>Análise do Tempo na Página</strong>: O tempo médio de 2h 36min é um dado atípico para a maioria dos sites de marketing. É fundamental entender se esse alto valor é intencional (ex: conteúdo de vídeo longo, cursos) ou se há alguma disfunção no tracking. Se for intencional, o foco deve ser em como monetizar esse engajamento. Se não, investigar e corrigir problemas de usabilidade ou carregamento.</li>
<li><strong>Alocação de Investimento em Mídia</strong>: A dominância de Google, Direct e Twitter como fontes de tráfego valida o investimento nessas plataformas. A empresa pode considerar explorar ainda mais o potencial desses canais, enquanto avalia a viabilidade de expandir ou otimizar o desempenho em fontes menores como Bing.</li>
</ul>
</section>
<section id="conclusão" class="level2">
<h2 class="anchored" data-anchor-id="conclusão">Conclusão</h2>
<p>O dashboard é uma ferramenta analítica poderosa que transforma dados brutos de marketing em inteligência acionável. Sua principal contribuição reside na capacidade de:</p>
<ul>
<li>Oferecer uma visão clara da performance geral das campanhas digitais e do comportamento do usuário.</li>
<li>Identificar a qualidade do tráfego por diferentes canais e a eficácia de campanhas específicas.</li>
<li>Fornecer insights sobre as principais origens de tráfego, auxiliando na alocação estratégica de recursos.</li>
</ul>
<p>Este projeto demonstra a habilidade em criar soluções de Business Intelligence que capacitam equipes de marketing a tomar decisões baseadas em dados, otimizar o desempenho de campanhas e, em última instância, impulsionar transações e receita em um ambiente digital competitivo.</p>
</section>
<section id="link-para-o-dashboard" class="level2">
<h2 class="anchored" data-anchor-id="link-para-o-dashboard">Link para o Dashboard:</h2>
<p><a href="https://app.powerbi.com/groups/me/reports/f01d9373-7129-45a1-b703-90d551b8f262/ReportSection?experience=power-bi" target="_blank" rel="noopener noreferrer"> Clique aqui para acessar o relatório no Power BI </a></p>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>